////////////////////////////////////////////////////////////////////
//
// Memory operation instructions
//
def template RVVLoadStoreDeclare {{
    /**
     * Static instruction class for "%(mnemonic)s".
     */
    class %(class_name)s : public %(base_class)s
    {
      private:
        %(reg_idx_arr_decl)s;

      protected:
        typedef uint8_t MemElemType;

      public:
        /// Constructor.
        %(class_name)s(ExtMachInst machInst);

        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, Trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          Trace::InstRecord *) const override;
    };
}};


def template RVVLoadStoreConstructor {{
    %(class_name)s::%(class_name)s(ExtMachInst machInst):
        %(base_class)s("%(mnemonic)s", machInst, %(op_class)s)
    {
        %(set_reg_idx_arr)s;
        %(constructor)s;
    }
}};


def template RVVLoadExecute {{
    Fault
    %(class_name)s::execute(
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;

        %(op_decl)s;
        %(op_rd)s;

        EA = Rs1;

        MemElemType memdata = 0;

        {
           for (int i = 0; i < 16; i++) {
               Fault fault =
                   readMemAtomicLE(xc, traceData, EA++,
                                       memdata, memAccessFlags);
               if (fault != NoFault)
                   return fault;
           }
        }

        %(memacc_code)s;

        %(op_wb)s;

        return NoFault;
    }
}};

def template RVVLoadInitiateAcc {{
    Fault
    %(class_name)s::initiateAcc(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Addr EA;

        %(op_src_decl)s;
        %(op_rd)s;

        MemElemType memData = 0;

        EA = Rs1;

        return initiateMemRead(xc, traceData, EA, memData, memAccessFlags);
    }
}};

def template RVVLoadCompleteAcc {{
    Fault
    %(class_name)s::completeAcc(PacketPtr pkt, ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Addr EA;

        %(op_decl)s;
        %(op_rd)s;

        EA = Rs1;

        MemElemType memData = 0;

        {
           for (int i = 0; i < 16; i++) {
               getMemLE(pkt, memData, traceData);
           }
        }

        %(memacc_code)s;
        %(op_wb)s;

        return NoFault;
    }
}};



let {{
def RVVLoadBase(name, Name, memacc_code, base_reg, mem_flags,
        inst_flags, base_class, postacc_code='', decode_template=BasicDecode,
        exec_template_base=''):
    # Make sure flags are in lists (convert to lists if not).
    mem_flags = makeList(mem_flags)
    inst_flags = makeList(inst_flags)

    iop = InstObjParams(name, Name, base_class,
        {'memacc_code': memacc_code, 'postacc_code': postacc_code,
         'base_reg':  base_reg},
        inst_flags)

    if mem_flags:
        mem_flags = [ 'Request::%s' % flag for flag in mem_flags ]
        s = '\n\tmemAccessFlags = ' + '|'.join(mem_flags) + ';'
        iop.constructor += s

    # select templates

    fullExecTemplate = eval(exec_template_base + 'Execute')
    initiateAccTemplate = eval(exec_template_base + 'InitiateAcc')
    completeAccTemplate = eval(exec_template_base + 'CompleteAcc')

    # (header_output, decoder_output, decode_block, exec_output)
    return (RVVLoadStoreDeclare.subst(iop),
        RVVLoadStoreConstructor.subst(iop),
        decode_template.subst(iop),
        fullExecTemplate.subst(iop) +
        initiateAccTemplate.subst(iop) +
        completeAccTemplate.subst(iop))
}};


def format RVVLoad(memacc_code, base_reg=[],
        mem_flags=[], inst_flags=[IsLoad]) {{
    (header_output, decoder_output, decode_block, exec_output) = \
        RVVLoadBase(name, Name, memacc_code, base_reg, mem_flags,
        inst_flags, 'RVVLoad', exec_template_base='RVVLoad')
}};
